/* CLASS OVERVIEW
 * - Provides further abstraction around the force generated by the Tyre
 * - Transforms force data coming from the Tyre
 * - Can move vertically in car space, and can rotate with steering and rolling
*/

#ifndef WHEEL_H
#define WHEEL_H
#pragma once

#include <glm/glm/trigonometric.hpp>
#include <glm/glm/gtx/rotate_vector.hpp>
#include <Framework/Physics/Spring.hpp>

#include "Tyre.h"

namespace Internal {
	class Wheel {
	private:
		glm::dvec3
			mBasePosition_car,           //Car-space, from the wheel's geometric (cylindrical) centre
			mPosition_car,               //Car-space, from the wheel's geometric (cylindrical) centre
			mTyreForce_world;            //World-space, total force generated by the tyre

		const double
			mRimRadius = 0.29491;        //m

		double
			mInertiaAboutAxle = 0.0,
			mAngularAcceleration = 0.0,  //Radians per second
			mAngularVelocity = 0.0,      //Radians per second
			mAngularPosition = 0.0,      //Radians from start
			mSteeringAngle = 0.0;        //Degrees, angle from default forward position, left < 0, right > 0

		char mRotationDirection = 0;     //1 = forward, -1 = backwards, 0 = not rotating

		Tyre mTyre;

	public:
		Wheel();
		~Wheel() = default;

		//Note: roadVel_car and load should be glm::dvec2(0.0) if vehicle is airborne
		void update(glm::dmat4 carToWorldRotation_car, glm::dvec3 terrainNormalUnderWheel, glm::dvec2 wheelVel_car, double load, double totalInputTorque, double dt);
		void reset();

		inline glm::dvec3 getBasePosition_car() const { return mBasePosition_car; }
		inline glm::dvec3 getPosition_car() const { return mPosition_car; }
		inline glm::dvec3 getContactPatchPosition_car() const { return mPosition_car - glm::dvec3(0.0, mRimRadius + mTyre.mDepth, 0.0); }
		inline glm::dvec3 getTyreForce_world() const { return mTyreForce_world; }
		inline double getAngularVelocity() const { return mAngularVelocity; }
		inline double getRPM() const { return mAngularVelocity / glm::two_pi<double>(); }
		inline double getAngularPosition() const { return mAngularPosition; }
		inline double getRimRadius() const { return mRimRadius; }
		inline double getTotalRadius() const { return mRimRadius + mTyre.getDepth(); }
		inline double getSteeringAngle() const { return mSteeringAngle; }
		inline char getRotationDirection() const { return mRotationDirection; }
		inline Tyre& getTyre() { return mTyre; }

		inline void resetToBasePosition() { mPosition_car = mBasePosition_car; }
		inline void setPosition_car(glm::dvec3 pos_car) { mPosition_car = pos_car; }
		inline void setBasePosition_car(glm::dvec3 basePos_car) { mBasePosition_car = basePos_car; }
		inline void setSteeringAngle(double newSteeringAngle) { mSteeringAngle = newSteeringAngle; }

	private:
		void updateAngularMotion(double totalTorque, double dt);
		void updateTyreForce_world(glm::dmat4 carToWorldRotation_car, glm::dvec3 terrainNormalUnderWheel);

	};
}

#endif
